# Ep.2 Shell脚本与工具推荐作业

1. 读一读man的帮助文档（或者tldr文档），试着用ls加选项
执行以下任务：

    - 列出所有文件，包括以.开头的隐藏文件
    - 将文件大小以方便阅读的格式列出（如，对于454279954字节这种大小，使其显示为454M）
    - 以时间降序排列列出的文件
 
    示例如下:
    ```sh
     -rw-r--r--   1 user group 1.1M Jan 14 09:53 baz
     drwxr-xr-x   5 user group  160 Jan 14 09:53 .
     -rw-r--r--   1 user group  514 Jan 14 06:42 bar
     -rw-r--r--   1 user group 106M Jan 13 12:12 foo
     drwx------+ 47 user group 1.5K Jan 12 18:08 ..
     ```

2. 写两个bash函数，marco和polo，执行如下功能：每当你执行marco的时候，将你当前shell所在的目录记录下来，以某种方式存储；在你执行polo的时候，无论你在哪里，回到运行marco时所在的目录。PS:为了debug方便，你可以将函数写在`marco.sh`里，然后通过`source marco.sh`启动或者重新加载写好的脚本。

3. 假设你有如下命令偶尔会出错，为了找出是什么问题，你需要在它出错的时候抓取它的输出。但是需要很长时间才能跑出一次错误的结果。写一个bash脚本运行它参数所指的命令直到它输出错误结果，并抓取它的标准输出和标准错误流（stdout，stderr）写入文件，同时打印出来。如果你能一并报告一下你一共跑了多少次这条命令才出错就更好了。

    ``` bash
    #!/usr/bin/env bash

    n=$(( RANDOM % 100 ))

    if [[ n -eq 42 ]]; then
        echo "出错啦"
        >&2 echo "错误是你算出了宇宙的终极答案"
        exit 1
    fi

    echo "计划通"
    ```
4. 正如我们课程中介绍的那样，`find`命令的`-exec`参数对查找结果依次执行操作非常强大，但是如果我们想要对查找结果全部执行某个操作（比如压缩为一个zip压缩包）要怎么办呢？目前你见过所有的程序都接受参数和STDIN（标准输入）作为参数，当使用管道（ `|` ）的时候，我们把一个命令的STDOUT接入另一个程序的STDIN使得程序之间可以互相连接。但是使用类似于`tar`（类似WinRAR的一种压缩软件）命令的时候，它只接受参数列表作为输入，不接受STDIN作为输入。为了转换STDIN与参数列表，我们可以使用`xargs`，它会将STDIN转化为参数列表，比如`ls | xargs rm`会删除当初目录下的所有文件。

    你的任务是写一条指令，递归的寻找你文件夹中的所有HTML文件，并且使用zip打包他们。（你可以通过范围的`touch`来创建一些随机的文件）注意你的命令应当在文件名中含有空格的时候也起作用。（提示：查查 `xargs`的-d选项）
5. （进阶）写一条指令或者脚本，递归的寻找你文件夹中最近被修改过的文件，更进一步的话，你能以降序列出文件吗？
